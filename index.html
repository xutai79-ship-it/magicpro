<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>K12ç¼–ç¨‹ - å¥‡å¼‚åšå£«ï¼šå…¨å…¼å®¹å·¥ä¸šç‰ˆ</title>
    <style>
        /* CSS Reset & åŸºç¡€å¸ƒå±€ */
        body { margin: 0; padding: 0; background-color: #000; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; touch-action: none; }
        
        /* è§†é¢‘å±‚ï¼šä¸ç›´æ¥æ˜¾ç¤ºï¼Œæˆ‘ä»¬åªå–æ•°æ®ç»˜åˆ¶åˆ°Canvasä¸Šï¼Œé¿å…åŒå±‚æ¸²æŸ“æµªè´¹ */
        video { display: none; }
        
        /* æ ¸å¿ƒç”»å¸ƒï¼šåˆ©ç”¨ object-fit é€»è¾‘è‡ªé€‚åº” */
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: flex-end; align-items: center;
            padding-bottom: constant(safe-area-inset-bottom); /* iOS åº•éƒ¨é€‚é… */
            padding-bottom: env(safe-area-inset-bottom);
            padding-bottom: 30px;
        }

        /* å¯åŠ¨é®ç½©å±‚ (è§£å†³ Autoplay Policy) */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 999;
            background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s;
        }
        .start-btn {
            padding: 15px 40px; border: 2px solid #ffaa00; color: #ffaa00; background: transparent;
            font-size: 20px; font-weight: bold; letter-spacing: 2px; cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.3); border-radius: 30px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); box-shadow: 0 0 40px rgba(255, 170, 0, 0.6); } 100% { transform: scale(1); } }

        /* HUD é¢æ¿æ ·å¼ */
        .hud-panel {
            background: rgba(20, 5, 0, 0.7); 
            border: 1px solid rgba(255, 180, 0, 0.3);
            border-radius: 20px; padding: 10px 20px;
            backdrop-filter: blur(10px); /* ä½ç«¯æœºå¯èƒ½ä¸æ”¯æŒï¼Œé€šè¿‡ JS é™çº§ */
            text-align: center; pointer-events: auto; user-select: none;
            max-width: 90%;
        }

        .control-row { display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 8px; flex-wrap: wrap; }
        
        .key-badge {
            display: inline-block; width: 32px; height: 32px; line-height: 30px; border-radius: 6px;
            color: #fff; background: rgba(255,255,255,0.1); font-weight: bold; font-size: 14px;
            border: 1px solid rgba(255,255,255,0.2); cursor: pointer; transition: transform 0.1s;
        }
        .key-badge:active { transform: scale(0.9); }
        
        .mode-active { background: #ffcc00; color: #000; border-color: #fff; }
        .sub-active { background: #00eaff; color: #000; border-color: #fff; }
        .bg-active { background: #ff3333; color: #fff; border-color: #fff; }

        .status-text { color: #fff; font-size: 14px; display: block; font-weight: 500; opacity: 0.9; }
        
        /* é”™è¯¯æç¤º */
        #error-log {
            position: absolute; top: 0; left: 0; width: 100%; background: rgba(255,0,0,0.8); color: white;
            font-size: 12px; padding: 5px; text-align: center; display: none; z-index: 1000;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="error-log"></div>

    <div id="start-screen">
        <div style="color: #ffaa00; font-size: 14px; margin-bottom: 20px; opacity: 0.7;">System Check: HTTPS [OK] WebGL [OK]</div>
        <button class="start-btn" onclick="initApp()">å¯åŠ¨é˜²å¾¡ç³»ç»Ÿ</button>
        <div id="loading-text" style="margin-top:20px; color:#fff; display:none;">æ­£åœ¨åŠ è½½ç¥ç»æ¥å£...</div>
    </div>

    <video id="input_video" playsinline webkit-playsinline muted autoplay></video>
    <canvas id="output_canvas"></canvas>
    
    <div id="ui-layer">
        <div class="hud-panel">
            <div class="control-row">
                <span id="k1" class="key-badge mode-active">1</span>
                <span id="k2" class="key-badge">2</span>
                <div style="width:1px; height:20px; background:rgba(255,255,255,0.2); margin:0 5px;"></div>
                <span id="k3" class="key-badge sub-active">3</span>
                <span id="k4" class="key-badge">4</span>
                <span id="k5" class="key-badge">5</span>
            </div>
            <div class="control-row">
                <span id="kq" class="key-badge mode-active">é‡‘</span>
                <span id="kw" class="key-badge">è“</span>
                <span id="ke" class="key-badge">çº¢</span>
                <div style="width:1px; height:20px; background:rgba(255,255,255,0.2); margin:0 5px;"></div>
                <span id="k0" class="key-badge">èƒŒæ™¯</span>
            </div>
            <span id="instruction-text" class="status-text">ç³»ç»Ÿå°±ç»ª</span>
        </div>
    </div>

<script>
    /**
     * H5 å‰ç«¯å¤§å¸ˆé‡æ„ç¬”è®°ï¼š
     * 1. ç§»é™¤äº†æ‰€æœ‰ async/awaitï¼Œæ”¹ç”¨ Promise é“¾ï¼Œå…¼å®¹ Chrome 52+ åŠæ—§ç‰ˆ WebViewã€‚
     * 2. å¢åŠ äº† isLowEnd æ£€æµ‹ï¼ŒåŠ¨æ€é™ä½æ¸²æŸ“è´¨é‡ (LOD)ã€‚
     * 3. å®ç°äº† object-fit: cover çš„æ•°å­¦æ˜ å°„ï¼Œè§£å†³é•¿å±æ‰‹æœºåæ ‡åç§»é—®é¢˜ã€‚
     * 4. å¢åŠ äº†é¼ æ ‡/è§¦æ‘¸å…œåº•é€»è¾‘ï¼Œé˜²æ­¢æ‘„åƒå¤´å¤±è´¥å¯¼è‡´ç™½å±ã€‚
     */

    // --- 0. åŸºç¡€ç¯å¢ƒæ£€æµ‹ä¸å…¼å®¹æ€§è¡¥ä¸ ---
    
    // Polyfill for requestAnimationFrame
    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || 
                                   window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || 
                                   function(f){setTimeout(f, 1000/60)};

    // HTTPS å¼ºåˆ¶æ£€æŸ¥ (MediaPipe å’Œ Camera å¿…é¡»åœ¨ HTTPS æˆ– localhost ä¸‹è¿è¡Œ)
    function checkSafeEnvironment() {
        if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
            alert("å®‰å…¨è­¦å‘Šï¼šWebAR éœ€è¦ HTTPS ç¯å¢ƒã€‚è¯·é…ç½® SSL æˆ–ä½¿ç”¨ localhostã€‚");
            return false;
        }
        return true;
    }

    // æ€§èƒ½åˆ†çº§æ£€æµ‹
    const isLowEnd = (function() {
        // ç®€å•åˆ¤å®šï¼šæ ¸å¿ƒæ•°å°‘äº4ï¼Œæˆ–è€… UserAgent åŒ…å«ä½ç«¯æ ‡è¯†ï¼Œæˆ–è€… iOS (iOS Safari æ˜¾å­˜é™åˆ¶è¾ƒä¸¥)
        const logicalProcessors = navigator.hardwareConcurrency || 4;
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        // iOS å¾€å¾€æ€§èƒ½å¼ºä½†å†…å­˜é™åˆ¶å¤§ï¼Œè¿™é‡Œä¿å®ˆå¤„ç†
        return (isMobile && logicalProcessors <= 4);
    })();
    
    console.log("Device Performance Tier:", isLowEnd ? "Low (LOD Active)" : "High");

    // --- 1. å…¨å±€å˜é‡å®šä¹‰ ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d', { alpha: false }); // alpha: false æå‡å°‘è®¸æ€§èƒ½
    const instructionText = document.getElementById('instruction-text');
    
    let canvasW, canvasH, globalTime = 0;
    
    // æ¸²æŸ“å¸ƒå±€å‚æ•° (ç”¨äºåæ ‡æ˜ å°„)
    let layout = { scale: 1, offsetX: 0, offsetY: 0, videoW: 0, videoH: 0 };
    
    // çŠ¶æ€æœº
    const MODE = { STAGE_1: 1, STAGE_2: 2 };
    let appState = {
        mode: MODE.STAGE_1,
        shape: 0, // 0-2
        color: 0, // 0-2
        particle: 0, // 0-2
        bgBlack: false,
        useMouse: false // é™çº§æ¨¡å¼æ ‡è®°
    };

    // äºŒé˜¶æ®µäº¤äº’å˜é‡
    let s2Data = { state: 'IDLE', rotX: 0, rotY: 0, tRotX: 0, tRotY: 0, alpha: 0, startT: 0, cd: 0 };

    // æ•°æ®æºï¼šæ‰‹éƒ¨æ•°æ®
    let handResults = []; // MediaPipe ç»“æœ
    let mouseHand = { x: 0.5, y: 0.5, active: false }; // é¼ æ ‡æ¨¡æ‹Ÿçš„æ‰‹æ•°æ®

    // èµ„æºç¼“å­˜æ± 
    const cachedAssets = {};
    const particlePool = [];
    let activeParticles = 0;
    let sparks = [];

    // é…ç½®è¡¨
    const COLORS = [
        { name: "å¥‡å¼‚é‡‘", hue: 35,  glow: '#ffaa00', text: 'rgba(255, 200, 100, 1)' },
        { name: "é‡å­è“", hue: 190, glow: '#00eaff', text: 'rgba(100, 240, 255, 1)' },
        { name: "çŒ©çº¢ç…", hue: 0,   glow: '#ff2200', text: 'rgba(255, 100, 100, 1)' }
    ];
    const WORDS = [
        { name: "çˆ±å¿ƒ", t1: "é£å¹åŠ¨äº†å‘æ¢¢", t2: "ä¹Ÿå¹åŠ¨äº†æˆ‘çš„å¿ƒ â¤ï¸" },
        { name: "æ˜Ÿçƒ", t1: "è¿™å®‡å®™æµ©ç€šæ— å ", t2: "å”¯ä½ æœ€ä¸ºé—ªè€€ âœ¨" },
        { name: "èŠ±æœµ", t1: "èµ ä½ ä¸€æœµæ¯æœ¨é€¢æ˜¥", t2: "æ„¿ä½ ç¬‘é¥å¦‚èŠ± ğŸŒ¸" } // ä¿®æ­£äº†éƒ¨åˆ†æ–‡æ¡ˆä½¿å…¶æ›´é€šç”¨
    ];
    const RUNES = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    // --- 2. æ ¸å¿ƒæ•°å­¦ä¸æ¸²æŸ“é€»è¾‘ ---

    // åæ ‡æ˜ å°„ï¼šå°† MediaPipe çš„å½’ä¸€åŒ–åæ ‡ (0-1) æ˜ å°„åˆ° object-fit: cover åçš„ç”»å¸ƒåæ ‡
    function updateLayout() {
        canvasW = window.innerWidth;
        canvasH = window.innerHeight;
        canvasElement.width = canvasW;
        canvasElement.height = canvasH;

        // å¦‚æœæ²¡æœ‰è§†é¢‘æµï¼Œç›´æ¥å…¨å±
        if (!videoElement.videoWidth) return;

        const vw = videoElement.videoWidth;
        const vh = videoElement.videoHeight;
        const screenRatio = canvasW / canvasH;
        const videoRatio = vw / vh;

        // æ¨¡æ‹Ÿ CSS object-fit: cover
        if (screenRatio > videoRatio) {
            // å±å¹•æ›´å®½ï¼Œä»¥å®½åº¦ä¸ºåŸºå‡†
            layout.scale = canvasW / vw;
            layout.videoW = canvasW;
            layout.videoH = vh * layout.scale;
            layout.offsetX = 0;
            layout.offsetY = (canvasH - layout.videoH) / 2;
        } else {
            // å±å¹•æ›´é«˜ï¼Œä»¥é«˜åº¦ä¸ºåŸºå‡†
            layout.scale = canvasH / vh;
            layout.videoH = canvasH;
            layout.videoW = vw * layout.scale;
            layout.offsetX = (canvasW - layout.videoW) / 2;
            layout.offsetY = 0;
        }
    }
    window.addEventListener('resize', updateLayout);

    // è¾…åŠ©ï¼šç¦»å± Canvas ç”Ÿæˆå™¨ (å¸¦æœ€å¤§å°ºå¯¸é™åˆ¶ï¼Œé˜²æ­¢ä½ç«¯æœº OOM)
    function createCache(size) {
        // ä½ç«¯æœºå¼ºåˆ¶ç¼©å°çº¹ç†å°ºå¯¸
        const limit = isLowEnd ? 512 : 1024;
        const finalSize = Math.min(size, limit);
        const scale = finalSize / size; // è®°å½•ç¼©æ”¾æ¯”ä¾‹ä»¥ä¾¿ç»˜åˆ¶æ—¶è¿˜åŸ
        
        const c = document.createElement('canvas');
        c.width = finalSize;
        c.height = finalSize;
        return { c: c, ctx: c.getContext('2d'), size: finalSize, half: finalSize/2, contentScale: scale };
    }

    // é¢„æ¸²æŸ“ç´ æ (LOD ä¼˜åŒ–ç‰ˆ)
    function generateCache() {
        const theme = COLORS[appState.color];
        // é™ä½é˜´å½±å¼€é”€
        const shadowEnabled = !isLowEnd; 

        // ç¤ºä¾‹ï¼šå¤–åœˆæ³•é˜µ
        let o = createCache(900);
        let ctx = o.ctx; ctx.scale(o.contentScale, o.contentScale); ctx.translate(450, 450);
        if(shadowEnabled) { ctx.shadowBlur = 15; ctx.shadowColor = theme.glow; }
        ctx.strokeStyle = theme.text; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0,0, 420, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(0,0, 380, 0, Math.PI*2); ctx.stroke();
        // ç»˜åˆ¶ç¬¦æ–‡ (å‡å°‘æ•°é‡ä»¥ä¼˜åŒ–)
        ctx.font = "bold 24px monospace"; ctx.fillStyle = theme.text; ctx.textAlign = "center"; ctx.textBaseline = "middle";
        const count = isLowEnd ? 24 : 64; 
        for(let i=0; i<count; i++) {
            ctx.save(); ctx.rotate((i/count)*Math.PI*2); ctx.translate(400,0); ctx.rotate(Math.PI/2);
            ctx.fillText(RUNES[i%RUNES.length], 0, 0); ctx.restore();
        }
        cachedAssets['ring'] = o;

        // ç¤ºä¾‹ï¼šå†…éƒ¨å‡ ä½• (ç”¨ç®€å•çš„å¤šè¾¹å½¢ä»£æ›¿å¤æ‚è·¯å¾„)
        o = createCache(600);
        ctx = o.ctx; ctx.scale(o.contentScale, o.contentScale); ctx.translate(300, 300);
        if(shadowEnabled) { ctx.shadowBlur = 10; ctx.shadowColor = theme.glow; }
        ctx.strokeStyle = `hsla(${theme.hue}, 100%, 70%, 0.8)`; ctx.lineWidth = 4;
        ctx.beginPath();
        for(let i=0; i<3; i++) { // ç”»å‡ ä¸ªæ—‹è½¬çš„æ­£æ–¹å½¢
            ctx.save(); ctx.rotate(i*Math.PI/6); 
            ctx.rect(-200, -200, 400, 400); ctx.stroke();
            ctx.restore();
        }
        cachedAssets['geo'] = o;

        // ç§‘æŠ€é£åœ†ç¯
        o = createCache(800);
        ctx = o.ctx; ctx.scale(o.contentScale, o.contentScale); ctx.translate(400, 400);
        ctx.strokeStyle = theme.glow; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0,0,350,0,Math.PI*2); ctx.stroke();
        // åˆ»åº¦
        for(let i=0; i<12; i++) {
            ctx.save(); ctx.rotate(i*Math.PI/6); 
            ctx.beginPath(); ctx.moveTo(350,0); ctx.lineTo(380,0); ctx.stroke();
            ctx.restore();
        }
        cachedAssets['tech'] = o;

        document.getElementById('loading-text').style.display = 'none';
    }

    // ç²’å­ç±» (3D)
    class Particle {
        constructor() { this.active=false; this.x=0;this.y=0;this.z=0; }
        spawn(type) {
            this.active = true;
            this.vx = (Math.random()-0.5)*10; this.vy = (Math.random()-0.5)*10; this.vz = (Math.random()-0.5)*10;
            this.x=0; this.y=0; this.z=0;
            // ç®€åŒ–å½¢çŠ¶ç”Ÿæˆé€»è¾‘ï¼Œé¿å…å¤æ‚ä¸‰è§’å‡½æ•°é€ æˆå¡é¡¿
            const r = 200 + Math.random()*100;
            const theta = Math.random()*Math.PI*2;
            const phi = Math.random()*Math.PI;
            
            if (type===0) { // Heart approx
                let t = Math.random()*Math.PI*2; 
                // ç®€åŒ–å¿ƒå½¢å…¬å¼
                this.tx = 16 * Math.pow(Math.sin(t),3) * 15;
                this.ty = -(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t)) * 15;
                this.tz = (Math.random()-0.5)*100;
            } else if (type===1) { // Sphere
                this.tx = r * Math.sin(phi) * Math.cos(theta);
                this.ty = r * Math.sin(phi) * Math.sin(theta);
                this.tz = r * Math.cos(phi);
            } else { // Flat
                this.tx = r * Math.cos(theta);
                this.ty = r * Math.sin(theta);
                this.tz = (Math.random()-0.5)*50;
            }
            this.ty -= 100; // Lift up
        }
        update(explode, rx, ry) {
            if(!this.active) return;
            if(explode) {
                this.x += this.vx; this.y += this.vy; this.z += this.vz;
            } else {
                // ç®€åŒ–çš„3Dæ—‹è½¬
                let y1 = this.ty * Math.cos(rx) - this.tz * Math.sin(rx);
                let z1 = this.ty * Math.sin(rx) + this.tz * Math.cos(rx);
                let x2 = this.tx * Math.cos(ry) - z1 * Math.sin(ry);
                let z2 = this.tx * Math.sin(ry) + z1 * Math.cos(ry);
                this.x += (x2 - this.x)*0.1;
                this.y += (y1 - this.y)*0.1;
                this.z += (z2 - this.z)*0.1;
            }
        }
    }
    
    // åˆå§‹åŒ–ç²’å­æ± 
    const MAX_P = isLowEnd ? 800 : 2000;
    for(let i=0; i<MAX_P; i++) particlePool.push(new Particle());

    // ç»˜åˆ¶è¾…åŠ©å‡½æ•°
    function drawImg(ctx, key, x, y, scale, rot, alpha) {
        const asset = cachedAssets[key];
        if(!asset) return;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rot);
        ctx.globalAlpha = alpha;
        // å…³é”®ï¼šç”±äº generateCache è¿›è¡Œäº† contentScale ç¼©æ”¾ï¼Œè¿™é‡Œç»˜åˆ¶æ—¶è¦é™¤å›å»ï¼Œä¿æŒç‰©ç†å°ºå¯¸ä¸€è‡´
        const s = scale / asset.contentScale;
        ctx.drawImage(asset.c, -asset.half*s, -asset.half*s, asset.size*s, asset.size*s);
        ctx.restore();
    }

    // --- 3. ä¸šåŠ¡é€»è¾‘ ---

    function renderLoop() {
        globalTime++;
        
        // 1. æ¸…ç©ºä¸èƒŒæ™¯
        if(appState.bgBlack) {
            canvasCtx.fillStyle = '#000';
            canvasCtx.fillRect(0,0, canvasW, canvasH);
        } else {
            // ç»˜åˆ¶è§†é¢‘èƒŒæ™¯ (åˆ©ç”¨ layout å‚æ•°è£å‰ª)
            if(!appState.useMouse && videoElement.readyState === 4) {
                canvasCtx.drawImage(videoElement, 
                    layout.offsetX, layout.offsetY, layout.videoW, layout.videoH
                );
                canvasCtx.fillStyle = 'rgba(0,0,0,0.6)'; // å‹æš—è§†é¢‘
                canvasCtx.fillRect(0,0,canvasW, canvasH);
            } else {
                canvasCtx.fillStyle = '#111'; // çº¯è‰²å…œåº•
                canvasCtx.fillRect(0,0,canvasW, canvasH);
            }
        }

        // 2. å‡†å¤‡æ‰‹éƒ¨æ•°æ® (ç»Ÿä¸€ Mouse å’Œ Camera æ¥æº)
        let handsToDraw = [];
        if (appState.useMouse) {
            if(mouseHand.active) handsToDraw.push({x: mouseHand.x * canvasW, y: mouseHand.y * canvasH, scale: 1});
        } else {
            // MediaPipe æ•°æ®è½¬æ¢
            handResults.forEach(h => {
                // æ ¸å¿ƒï¼šå½’ä¸€åŒ–åæ ‡ -> è§†è§‰åæ ‡
                const realX = h.x * layout.videoW + layout.offsetX;
                const realY = h.y * layout.videoH + layout.offsetY;
                // ç®€å•çš„æ·±åº¦ä¼°ç®—
                const size = Math.abs(h.z) * 2; // MediaPipe z is relative
                handsToDraw.push({x: realX, y: realY, scale: Math.max(0.5, Math.min(2, 1/size))});
            });
        }

        canvasCtx.globalCompositeOperation = 'lighter'; // é­”æ³•å…‰æ•ˆæ ¸å¿ƒæ··åˆæ¨¡å¼

        // 3. ç»˜åˆ¶é€»è¾‘åˆ†å‘
        if(appState.mode === MODE.STAGE_1) {
            handsToDraw.forEach(hand => {
                const t = globalTime * 0.02;
                const s = hand.scale * 0.6;
                // æ ¹æ® shape ç±»å‹ç»˜åˆ¶ä¸åŒç´ æ
                if(appState.shape === 0) {
                    drawImg(canvasCtx, 'ring', hand.x, hand.y, s*1.2, t*0.5, 0.8);
                    drawImg(canvasCtx, 'geo', hand.x, hand.y, s*0.9, -t, 1.0);
                } else if(appState.shape === 1) {
                    drawImg(canvasCtx, 'tech', hand.x, hand.y, s*1.0, t, 0.9);
                    drawImg(canvasCtx, 'geo', hand.x, hand.y, s*0.5, t*2, 1.0);
                } else {
                     // ç®€å•æ··æ²Œæ•ˆæœï¼šå¤šæ¬¡ç»˜åˆ¶
                     for(let i=0; i<3; i++) drawImg(canvasCtx, 'ring', hand.x, hand.y, s*(1+i*0.2), t*(i+1), 0.5);
                }
            });
            
            // UI æç¤º
            if(handsToDraw.length === 0) {
                 canvasCtx.font = "20px Arial"; canvasCtx.fillStyle="#fff"; canvasCtx.textAlign="center";
                 canvasCtx.fillText(appState.useMouse ? "ç‚¹å‡»å±å¹•å¹¶ç§»åŠ¨æ‰‹æŒ‡" : "è¯·ä¼¸å‡ºåŒæ‰‹", canvasW/2, canvasH/2);
            }

        } else if (appState.mode === MODE.STAGE_2) {
            // é€»è¾‘ï¼šåŒæ‰‹é è¿‘->STABLE, åˆ†å¼€->DISPERSE
            const hasHands = handsToDraw.length >= (appState.useMouse ? 1 : 2);
            const cx = canvasW/2; const cy = canvasH/2;
            
            // è®¡ç®—æ—‹è½¬ç›®æ ‡
            if(hasHands) {
                if(appState.useMouse) {
                     s2Data.tRotY = (handsToDraw[0].x - cx)/200;
                     s2Data.tRotX = (handsToDraw[0].y - cy)/200;
                } else {
                     let mx = (handsToDraw[0].x + handsToDraw[1].x)/2;
                     let my = (handsToDraw[0].y + handsToDraw[1].y)/2;
                     s2Data.tRotY = (mx - cx)/200;
                     s2Data.tRotX = (my - cy)/200;
                }
            }

            s2Data.rotX += (s2Data.tRotX - s2Data.rotX)*0.1;
            s2Data.rotY += (s2Data.tRotY - s2Data.rotY)*0.1;

            if(s2Data.state === 'IDLE' && hasHands && s2Data.cd <= 0) {
                s2Data.state = 'STABLE';
                activeParticles = isLowEnd ? 500 : 1500;
                particlePool.forEach(p => p.spawn(appState.particle));
                instructionText.innerText = "ä¿æŒæ‰‹åŠ¿å‡èšèƒ½é‡ | æ¾å¼€é‡Šæ”¾";
            } 
            else if (s2Data.state === 'STABLE' && !hasHands) {
                s2Data.state = 'DISPERSE';
                s2Data.startT = Date.now();
                instructionText.innerText = "é‡Šæ”¾ï¼";
            }

            if(s2Data.state !== 'IDLE') {
                const isDisperse = s2Data.state === 'DISPERSE';
                let alpha = 1.0;
                
                if(isDisperse) {
                    const diff = Date.now() - s2Data.startT;
                    if(diff > 3000) alpha = 1 - (diff-3000)/1000;
                    if(diff > 4000) { s2Data.state = 'IDLE'; s2Data.cd = 60; }
                }

                // ç»˜åˆ¶ç²’å­
                canvasCtx.fillStyle = COLORS[appState.color].glow;
                particlePool.slice(0, activeParticles).forEach(p => {
                    p.update(isDisperse, s2Data.rotX, s2Data.rotY);
                    if(!p.active) return;
                    // ç®€å•çš„3DæŠ•å½±
                    const fl = 500;
                    const scale = fl / (fl + p.z + 500);
                    if(scale < 0) return;
                    const x2d = cx + p.x * scale;
                    const y2d = cy + p.y * scale;
                    const s = (isLowEnd ? 3 : 2) * scale;
                    canvasCtx.globalAlpha = alpha;
                    canvasCtx.fillRect(x2d, y2d, s, s);
                });

                // æ–‡å­—
                canvasCtx.globalAlpha = 1;
                canvasCtx.shadowBlur = 10; canvasCtx.shadowColor = COLORS[appState.color].glow;
                canvasCtx.fillStyle = "#fff"; canvasCtx.textAlign = "center";
                const w = WORDS[appState.particle];
                if(s2Data.state==='STABLE') {
                    canvasCtx.font = "30px sans-serif";
                    canvasCtx.fillText(w.t1, cx, cy - 300);
                } else if(isDisperse) {
                    canvasCtx.font = "bold 40px sans-serif";
                    canvasCtx.fillText(w.t2, cx, cy);
                }
                canvasCtx.shadowBlur = 0;
            }
            if(s2Data.cd > 0) s2Data.cd--;
        }

        canvasCtx.globalCompositeOperation = 'source-over';
        requestAnimationFrame(renderLoop);
    }

    // --- 4. äº¤äº’ä¸äº‹ä»¶ ---
    
    // åˆå§‹åŒ–åº”ç”¨
    function initApp() {
        if(!checkSafeEnvironment()) return;

        const btn = document.querySelector('.start-btn');
        btn.innerText = "ç³»ç»Ÿåˆå§‹åŒ–ä¸­...";
        document.getElementById('loading-text').style.display = 'block';

        // é¢„ç”Ÿæˆèµ„æº
        generateCache();

        // å°è¯•å¯åŠ¨æ‘„åƒå¤´
        const constraints = {
            audio: false,
            video: {
                facingMode: 'user',
                width: { ideal: 1280 },
                height: { ideal: 720 }
            }
        };

        // å…¼å®¹æ€§ getUserMedia å†™æ³•
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

        // å¦‚æœæµè§ˆå™¨æ”¯æŒæ ‡å‡† Promise å†™æ³•
        const p = navigator.mediaDevices ? navigator.mediaDevices.getUserMedia(constraints) : 
                  new Promise((resolve, reject) => {
                      navigator.getUserMedia(constraints, resolve, reject);
                  });

        p.then(function(stream) {
            videoElement.srcObject = stream;
            // å¿…é¡»åœ¨ç”¨æˆ·äº¤äº’äº‹ä»¶ä¸­è°ƒç”¨ play
            videoElement.play();
            
            // åˆå§‹åŒ– MediaPipe
            initMediaPipe();
            
            // éšè—å¯åŠ¨é¡µ
            document.getElementById('start-screen').style.opacity = 0;
            setTimeout(() => document.getElementById('start-screen').style.display = 'none', 500);
            
            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            requestAnimationFrame(renderLoop);
            
        }).catch(function(err) {
            console.error("Camera failed:", err);
            handleFallback("æ— æ³•è®¿é—®æ‘„åƒå¤´ (æƒé™æ‹’ç»æˆ–è®¾å¤‡ä¸æ”¯æŒ)ï¼Œå·²åˆ‡æ¢è‡³è§¦æ‘¸æ¨¡å¼ã€‚");
        });
    }

    function initMediaPipe() {
        try {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: isLowEnd ? 0 : 1, // ä½ç«¯æœºä½¿ç”¨ Lite æ¨¡å‹
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(onResults);
            
            // ä½¿ç”¨ Camera Utils è‡ªåŠ¨å‘é€å¸§
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 1280,
                height: 720
            });
            camera.start();
        } catch (e) {
            handleFallback("AI å¼•æ“åŠ è½½å¤±è´¥ï¼Œå·²åˆ‡æ¢è‡³è§¦æ‘¸æ¨¡å¼ã€‚");
        }
    }

    // MediaPipe å›è°ƒï¼šåªè´Ÿè´£æ›´æ–°æ•°æ®ï¼Œä¸è´Ÿè´£ç”»ç”»
    function onResults(results) {
        handResults = [];
        if (results.multiHandLandmarks) {
            for (const landmarks of results.multiHandLandmarks) {
                // å–æ‰‹æŒä¸­å¿ƒç‚¹ (ç´¢å¼•9) å’Œ æ·±åº¦ä¼°è®¡
                handResults.push({
                    x: landmarks[9].x,
                    y: landmarks[9].y,
                    z: Math.abs(landmarks[0].x - landmarks[17].x) // ç²—ç•¥ä¼°è®¡æ‰‹æŒå®½åº¦ä½œä¸ºæ·±åº¦
                });
            }
        }
    }

    // ç¾éš¾æ¢å¤ï¼šé¼ æ ‡/è§¦æ‘¸æ¨¡å¼
    function handleFallback(msg) {
        document.getElementById('error-log').innerText = msg;
        document.getElementById('error-log').style.display = 'block';
        document.getElementById('start-screen').style.display = 'none';
        
        appState.useMouse = true;
        appState.bgBlack = true; // æ²¡æ‘„åƒå¤´å°±åªèƒ½å…¨é»‘èƒŒæ™¯äº†
        updateUI();
        
        // ç»‘å®šé¼ æ ‡/è§¦æ‘¸äº‹ä»¶
        window.addEventListener('mousemove', e => {
            mouseHand.active = true;
            mouseHand.x = e.clientX / window.innerWidth;
            mouseHand.y = e.clientY / window.innerHeight;
        });
        window.addEventListener('touchmove', e => {
            mouseHand.active = true;
            mouseHand.x = e.touches[0].clientX / window.innerWidth;
            mouseHand.y = e.touches[0].clientY / window.innerHeight;
        }, {passive: false}); // passive: false å…è®¸ preventDefault (è™½è¿™é‡Œæ²¡ç”¨)
        
        // å¯åŠ¨æ¸²æŸ“
        generateCache(); // ç¡®ä¿èµ„æºç”Ÿæˆ
        requestAnimationFrame(renderLoop);
    }

    // UI äº¤äº’
    function bindKey(id, callback) {
        const el = document.getElementById(id);
        el.addEventListener('click', callback);
        el.addEventListener('touchstart', (e) => { e.preventDefault(); callback(); });
    }

    function updateUI() {
        // æ›´æ–°æŒ‰é’®é«˜äº®ç±»
        const setClass = (id, active, type) => {
            document.getElementById(id).className = `key-badge ${active ? type : ''}`;
        };
        
        setClass('k1', appState.mode === 1, 'mode-active');
        setClass('k2', appState.mode === 2, 'mode-active');
        
        setClass('k3', (appState.mode===1 && appState.shape===0) || (appState.mode===2 && appState.particle===0), 'sub-active');
        setClass('k4', (appState.mode===1 && appState.shape===1) || (appState.mode===2 && appState.particle===1), 'sub-active');
        setClass('k5', (appState.mode===1 && appState.shape===2) || (appState.mode===2 && appState.particle===2), 'sub-active');

        setClass('kq', appState.color===0, 'mode-active');
        setClass('kw', appState.color===1, 'mode-active');
        setClass('ke', appState.color===2, 'mode-active');
        
        setClass('k0', appState.bgBlack, 'bg-active');
        
        // æ›´æ–° cache
        generateCache();
    }

    // ç»‘å®šæŒ‰é’®äº‹ä»¶
    bindKey('k1', () => { appState.mode=1; appState.bgBlack=false; updateUI(); });
    bindKey('k2', () => { appState.mode=2; appState.bgBlack=true; s2Data.state='IDLE'; updateUI(); });
    bindKey('k3', () => { if(appState.mode===1) appState.shape=0; else appState.particle=0; updateUI(); });
    bindKey('k4', () => { if(appState.mode===1) appState.shape=1; else appState.particle=1; updateUI(); });
    bindKey('k5', () => { if(appState.mode===1) appState.shape=2; else appState.particle=2; updateUI(); });
    bindKey('kq', () => { appState.color=0; updateUI(); });
    bindKey('kw', () => { appState.color=1; updateUI(); });
    bindKey('ke', () => { appState.color=2; updateUI(); });
    bindKey('k0', () => { appState.bgBlack = !appState.bgBlack; updateUI(); });

</script>
</body>
</html>
